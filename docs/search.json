[
  {
    "objectID": "git_submodules.html",
    "href": "git_submodules.html",
    "title": "Git Submodules - Basic Explanation",
    "section": "",
    "text": "Git Submodules - Basic Explanation\n\nWhy submodules?\nIn Git you can add a submodule to a repository. This is basically a repository embedded in your main repository. This can be very useful. A couple of usecases of submodules:\n\nSeparate big codebases into multiple repositories.\nUseful if you have a big project that contains multiple subprojects. You can make every subproject a submodule. This way you’ll have a cleaner Git log, because the commits are specific to a certain submodule.\nRe-use the submodule in multiple parent repositories.\nUseful if you have multiple repositories that share a common component. With this approach you can easily update that shared component in all the repositories that added them as a submodule. This is a lot more convienient than copy-pasting the code into the repositories.\n\n\n\nBasics\nWhen you add a submodule in Git, you don’t add the code of the submodule to the main repository, you only add information about the submodule that is added to the main repository. This information describes which commit the submodule is pointing at. This way, the submodule’s code won’t automatically be updated if the submodule’s repository is updated. This is good, because your main repository might not work with the latest commit of the submodule; it prevents unexpected behaviour.\n\n\nAdding a submodule\nYou can add a submodule to a repository like this:\ngit submodule add git@github.com:path_to/submodule.git path-to-submodule\ngit submodule add jpowerj@github.com:dsan-globals.git dsan-globals\nWith default configuration, this will check out the code of the submodule.git repository to the path-to-submodule directory, and will add information to the main repository about this submodule, which contains the commit the submodule points to, which will be the current commit of the default branch (usually the master branch) at the time this command is executed.\nAfter this operation, if you do a git status you’ll see two files in the Changes to be committed list: the .gitmodules file and the path to the submodule. When you commit and push these files, you’ll commit/push the submodule to the origin.\n\n\nGetting the submodule’s code\nIf a new submodule is created by one person, the other people in the team need to initiate this submodule. First you have to get the information about the submodule, this is retrieved by a normal git pull. If there are new submodules you’ll see it in the output of git pull. Then you’ll have to initiate them with:\ngit submodule init\nThis will pull all the code from the submodule and place it in the directory that it’s configured to.\nIf you’ve cloned a repository that makes use of submodules, you should also run this command to get the submodule’s code. This is not automatically done by git clone. However, if you add the --recurse-submodules flag, it will.\n\n\nPushing updates in the submodule\nThe submodule is just a separate repository. If you want to make changes to it, you should make the changes in its repository and push them like in a regular Git repository: Just execute the git commands in the submodule’s directory. However, you should also let the main repository know that you’ve updated the submodule’s repository, and make it use the new commit of the repository of the submodule. Because if you make new commits inside a submodule, the main repository will still point to the old commit.\nIf there are changes in the submodule’s repository, and you do a git status in the main repository, then the submodule will be in the Changes not staged for commit list, and will have the text (modified content) behind it. This means that the code of the submodule is checked out on a different commit than the main repository is pointing to. To make the main repository point to this new commit, you should create another commit in the main repository.\nThe next sections describe different scenarios on doing this.\n\nMake changes inside a submodule\n\ncd inside the submodule directory.\nMake the desired changes.\ngit commit the new changes.\ngit push the new commit.\ncd back to the main repository.\nIn git status you’ll see that the submodule directory is modified.\nIn git diff you’ll see the old and new commit pointers.\nWhen you git commit in the main repository, it will update the pointer.\n\n\n\nUpdate the submodule pointer to a different commit\n\ncd inside the submodule directory.\ngit checkout the branch/commit you want to point to.\ncd back to the main repository.\nIn git status you’ll see that the submodule directory is modified.\nIn git diff you’ll see the old and new commit pointers.\nWhen you git commit in the main repository, it will update the pointer.\n\n\n\nIf someone else updated the submodule pointer\nIf someone updated a submodule, the other team-members should update the code of their submodules. This is not automatically done by git pull, because with git pull it only retrieves the information that the submodule is pointing to another commit, but doesn’t update the submodule’s code.\nTo see the current commits that are checked out for all your submodules:\ngit submodule status\nTo update the code of your submodules:\ngit submodule update\nIf a submodule is not initiated yet, add the --init flag. If any submodule has submodules itself, you can add the --recursive flag to recursively init and update submodules.\n\nWhat happens if you don’t run this command?\nIf you don’t run this command, the code of your submodule is checked out to an old commit. When you do git status in the main repository, you will see the submodule in the Changes not staged for commit list with the text (modified content) behind it. If you would do a git status inside the submodule, it would say HEAD detached at &lt;commit-hash&gt;. This is not because you changed the submodule’s code, but because its code is checked out to a different commit than the commit used in the main repository. So in the main repo, Git sees this as a change, but actually you just didn’t update the submodule. So if you’re working with submodules, don’t forget to keep your submodules up-to-date.\n\n\n\n\nMaking it easier for everyone\nIt is sometimes annoying if you forget to initiate and update your submodules. Fortunately, there are some tricks to make it easier:\ngit clone --recurse-submodules\nThis will clone a repository and also init / update any possible submodules the repository has.\ngit pull --recurse-submodules\nThis will pull the main repository and also it’s submodules.\nAnd you can make it easier with aliases:\ngit config --global alias.clone-all 'clone --recurse-submodules'\ngit config --global alias.pull-all 'pull --recurse-submodules'"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "DSAN 6000 Slide Hub",
    "section": "",
    "text": "This webpage just serves as a hub collecting Jeff’s slides for DSAN 6000: Big Data and Cloud Computing, Fall 2025 at Georgetown University. It is not a replacement for the main course webpage!\nSection 01 of the course takes place on Wednesday from 6:30 to 9:00pm in Healy 105.\n\n\n\n\n\n\n\n\n\n\nTitle\n\n\n\nDate\n\n\n\n\n\n\n\n\nWeek 1: Introduction to Big Data\n\n\nAug 28\n\n\n\n\n\n\nNo matching items",
    "crumbs": [
      "<i class='bi bi-house pe-1'></i> Home"
    ]
  },
  {
    "objectID": "writeups/relative-intensity/index.html",
    "href": "writeups/relative-intensity/index.html",
    "title": "Computing and Evaluating Relative Intensity Ratios",
    "section": "",
    "text": "As we approached the midterm, there were two “threads” in what we were learning:\n\nIntensity function estimation\nRelative risk surfaces\n\nMy goal was to bring them together, which I was able to do to some extent during Week 9, but there were a lot of details I had to sweep under the rug in order to get to the basic relative risk surface visualization.\nSo, since it has turned out to be one of the more common techniques needed across different final projects, I wanted to create this writeup as a “how-to” guide.\nTo give some specific examples (each of them corresponds to more than one final project!), you may find yourself with:\n\nOne set of points representing cases of interest (say, of a disease), with\nAnother set of points representing a sample of the population from which the cases are drawn.\n\nOr:\n\nOne estimated intensity function representing damaged buildings (and hence buildings needing reconstruction), with\nAnother intensity function representing the danger construction crews would face in going and rebuilding those buildings (estimated, e.g., from points representing bomb attacks).\n\nOr more generally:\n\nOne set of points representing events, with\nAnother set of points representing base rates.\n\nIn each of these cases, the idea is that an intensity function representing the ratio of the first bullet point and the second bullet point is often more useful than the intensity functions considered on their own."
  },
  {
    "objectID": "w01/index.html",
    "href": "w01/index.html",
    "title": "Week 1: Introduction to Big Data",
    "section": "",
    "text": "Open slides in new tab →",
    "crumbs": [
      "Week 1: Aug 28"
    ]
  },
  {
    "objectID": "w01/index.html#references",
    "href": "w01/index.html#references",
    "title": "Week 1: Introduction to Big Data",
    "section": "References",
    "text": "References",
    "crumbs": [
      "Week 1: Aug 28"
    ]
  },
  {
    "objectID": "w01/slides.html#references",
    "href": "w01/slides.html#references",
    "title": "Week 1: Introduction to Big Data",
    "section": "References",
    "text": "References"
  }
]